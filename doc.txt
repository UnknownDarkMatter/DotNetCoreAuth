JWTAuth-master.zip
	JWT Authentication In ASP.NET Core
		https://www.freecodespot.com/blog/jwt-authentication-in-dotnet-core/


JwtAuthentication-master.zip
	JWT Authentication with Symmetric Encryption in ASP.NET Core
		https://eduardstefanescu.dev/2020/04/11/jwt-authentication-with-symmetric-encryption-in-asp-dotnet-core/
		https://github.com/StefanescuEduard/JwtAuthentication

Samples.IdentityServer4.zip
	Implement OAuth2 and OpenID Connect (Using IdentityServer4) in ASP.NET Core 5
		https://www.youtube.com/watch?v=vJqR_1dQIkc
		https://procodeguide.com/programming/oauth2-and-openid-connect-in-aspnet-core/
		https://github.com/procodeguide/ProCodeGuide.Samples.IdentityServer4


#### pour générer un certificat SSL
dotnet dev-certs https -p token-jwt-secret-http2 -ep C:\sources\...\token-jwt-secret-http2.pfx
dotnet dev-certs https -p token-jwt-secret -ep C:\sources\DotNetCoreAuth\Samples.IdentityServer4\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret.pfx

l'export de certificat créé depuis inetmgr provoque une erreur NS_ERROR_NET_INADEQUATE_SECURITY


Connection refused? Docker networking and how it impacts your image
	https://pythonspeed.com/articles/docker-connection-refused/

##### les certificats doivent être approuvés pour être utilisés avec SSL
AuthenticationException: The remote certificate is invalid because of errors in the certificate chain: UntrustedRoot

dotnet dev-certs https --clean
dotnet dev-certs https --trust
dotnet dev-certs https -p token-jwt-secret       -ep C:\sources\DotNetCoreAuth\Samples.IdentityServer4\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret.pfx
dotnet dev-certs https -p token-jwt-secret-http2 -ep C:\sources\DotNetCoreAuth\Samples.IdentityServer4\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret-http2.pfx
dotnet dev-certs https -p token-jwt-secret-http2 -ep C:\sources\DotNetCoreAuth\Samples.IdentityServer4\ProCodeGuide.IdServer4.Client\token-jwt-secret-http2.pfx

il faut créer un certificat racine de confiance avec "dotnet dev-certs https --trust" puis générer des certificats sous le certificat racine de confiance de dev


######## les certicifats générés sur localhost ne fonctionnent pas dans les containers dockers
au lieu de creer le certificat avec "dotnet dev-certs https" on le crée via powershell en précisant des noms d'host qui sont les hostname des containers docker

#### Powershell en mode admin :
	#create a SAN cert for both host.docker.internal and localhost
	#$cert = New-SelfSignedCertificate -DnsName "myidentityserver", "mywebsite", "1-FR92PC-723.Agap2-fra.local", "localhost" -CertStoreLocation cert:\localmachine\my
	$cert = New-SelfSignedCertificate -DnsName @("myidentityserver", "mywebsite", "localhost") -CertStoreLocation cert:\localmachine\my
	#$cert = New-SelfSignedCertificate -DnsName @("server.docker.local", "localhost") -CertStoreLocation cert:\localmachine\my
   
	#export it for docker container to pick up later
	$password = ConvertTo-SecureString -String "token-jwt-secret" -Force -AsPlainText
	$certKeyPath = "C:\sources\DotNetCoreAuth\Samples.IdentityServer4\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret.pfx"
	Export-PfxCertificate -Cert $cert -FilePath $certKeyPath -Password $password
	$rootCert1 = $(Import-PfxCertificate -FilePath $certKeyPath -CertStoreLocation 'Cert:\LocalMachine\Root' -Password $password)
	
	$password = ConvertTo-SecureString -String "token-jwt-secret-http2" -Force -AsPlainText
	$certKeyPath = "C:\sources\DotNetCoreAuth\Samples.IdentityServer4\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret-http2.pfx"
	Export-PfxCertificate -Cert $cert -FilePath $certKeyPath -Password $password
	$rootCert2 = $(Import-PfxCertificate -FilePath $certKeyPath -CertStoreLocation 'Cert:\LocalMachine\Root' -Password $password)
	
	$password = ConvertTo-SecureString -String "token-jwt-secret-http2" -Force -AsPlainText
	$certKeyPath = "C:\sources\DotNetCoreAuth\Samples.IdentityServer4\ProCodeGuide.IdServer4.Client\token-jwt-secret-http2.pfx"
	Export-PfxCertificate -Cert $cert -FilePath $certKeyPath -Password $password
	$rootCert3 = $(Import-PfxCertificate -FilePath $certKeyPath -CertStoreLocation 'Cert:\LocalMachine\Root' -Password $password)

	# trust it on your host machine
	$store = New-Object System.Security.Cryptography.X509Certificates.X509Store "TrustedPublisher","LocalMachine"
	$store.Open("ReadWrite")
	$store.Add($cert)
	$store.Add($rootCert1)
	$store.Add($rootCert2)
	$store.Add($rootCert3)
	$store.Close()
	
nettoyer
	$certFilePath = "C:\sources\DotNetCoreAuth\Samples.IdentityServer4\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret.pfx"
	Get-ChildItem $certFilePath | Remove-Item
	$certFilePath = "C:\sources\DotNetCoreAuth\Samples.IdentityServer4\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret-http2.pfx"
	Get-ChildItem $certFilePath | Remove-Item
	$certFilePath = "C:\sources\DotNetCoreAuth\Samples.IdentityServer4\ProCodeGuide.IdServer4.Client\token-jwt-secret-http2.pfx"
	Get-ChildItem $certFilePath | Remove-Item

deplacer le certificat de Personnel à autorités racines de confiance
redémarrer l'ordinateur

	----- How to allow HTTPS connections from both localhost and container towards an ASP.NET Core Web API application?
		https://stackoverflow.com/questions/61997345/how-to-allow-https-connections-from-both-localhost-and-container-towards-an-asp
		https://blog.wiseowls.co.nz/index.php/2020/06/27/running-https-with-docker/


CN = myidentityserver mais dans le certificat, autre nom de l'objet
Nom DNS=myidentityserver
Nom DNS=mywebsite
Nom DNS=localhost



AuthenticationException: The remote certificate is invalid because of errors in the certificate chain: UntrustedRoot

Il faut à la fois créer des certificats pour le hostname et aussi enregistrer dans les containers les autorités de certifications qui certifient les certificats

###################### Generer des certificats exportables dans les containers Docker
télécharger OpenSSL : https://sourceforge.net/projects/openssl/
copier le contenu du bin dans C:\OpenSSL
Ajouter C:\OpenSSL au path

Créer un repertoire de travail C:\sources\DotNetCoreAuth\Samples.IdentityServer4\OpenSSL
creer un fichier localhost.docker.conf contenant dans les alt_names les noms de domaines à autoriser
	[req]
	default_bits = 2048
	prompt = no
	default_md = sha256
	x509_extensions = v3_req
	req_extensions = v3_req
	distinguished_name = dn

	[ dn ]
	C=FR
	ST=Avenue Andre Morizet
	L=Boulogne Billancourt
	O=End Point
	OU=Docker and localhost
	emailAddress=toto@toto.com
	CN = localhost


	[ v3_req ]
	# Extensions to add to a certificate request
	subjectAltName = @alt_names

	[ alt_names ]
	DNS.1 = localhost
	DNS.2 = myidentityserver
	DNS.3 = mywebsite


REM ######## Code a executer pour créer les certificats et clefs en localhost ##############
ouvrir un prompt DOS dans le répertoire de travail

openssl req -new -x509 -sha256 -nodes -newkey rsa:2048 -config localhost.docker.conf -out localhost.docker.crt -keyout localhost.docker.key

openssl pkcs12 -export -inkey localhost.docker.key -in localhost.docker.crt -out ..\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret.pfx -passin pass:token-jwt-secret -passout pass:token-jwt-secret
openssl pkcs12 -export -inkey localhost.docker.key -in localhost.docker.crt -out ..\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret-http2.pfx -passin pass:token-jwt-secret-http2 -passout pass:token-jwt-secret-http2
openssl pkcs12 -export -inkey localhost.docker.key -in localhost.docker.crt -out ..\ProCodeGuide.IdServer4.Client\token-jwt-secret-http2.pfx -passin pass:token-jwt-secret-http2 -passout pass:token-jwt-secret-http2

sous Windows il faut installer le certificat en double cliquant sur le crt
REM ######## Code a executer pour créer les certificats et clefs en localhost ##############

REM ######## Code a executer pour créer les certificats et clefs de docker ##############
ouvrir un prompt DOS dans le répertoire C:\sources\DotNetCoreAuth\Samples.IdentityServer4\OpenSSL

openssl req -new -x509 -sha256 -nodes -newkey rsa:2048 -config myidentityserver.docker.conf -out myidentityserver.docker.crt -keyout myidentityserver.docker.key
openssl pkcs12 -export -inkey myidentityserver.docker.key -in myidentityserver.docker.crt -out ..\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret.pfx -passin pass:token-jwt-secret -passout pass:token-jwt-secret
openssl pkcs12 -export -inkey myidentityserver.docker.key -in myidentityserver.docker.crt -out ..\ProCodeGuide.Samples.IdentityServer4\token-jwt-secret-http2.pfx -passin pass:token-jwt-secret-http2 -passout pass:token-jwt-secret-http2
xcopy /Y myidentityserver.docker.crt ..\ProCodeGuide.Samples.IdentityServer4\
xcopy /Y myidentityserver.docker.crt ..\ProCodeGuide.IdServer4.Client\


openssl req -new -x509 -sha256 -nodes -newkey rsa:2048 -config mywebsite.docker.conf -out mywebsite.docker.crt -keyout mywebsite.docker.key
openssl pkcs12 -export -inkey mywebsite.docker.key -in mywebsite.docker.crt -out ..\ProCodeGuide.IdServer4.Client\token-jwt-secret-http2.pfx -passin pass:token-jwt-secret-http2 -passout pass:token-jwt-secret-http2
xcopy /Y mywebsite.docker.crt ..\ProCodeGuide.Samples.IdentityServer4\
xcopy /Y mywebsite.docker.crt ..\ProCodeGuide.IdServer4.Client\

sous linux il faut copier le crt dans /usr/local/share/ca-certificates et lancer la commande update-ca-certificates
NET::ERR_CERT_AUTHORITY_INVALID : pas de certificat copié
NET::ERR_CERT_AUTHORITY_INVALID : certificats avec CN=myidentityserver et mywebsite
NET::ERR_CERT_AUTHORITY_INVALID : certificats avec CN=myidentityserver et mywebsite ajoutés sous Windows dans autorité de certification racine
REM ######## Code a executer pour créer les certificats et clefs de docker ##############




penser à changer le CN dans le fichier de config de sorte à mettre le hostname avant d'executer openssh pour générer le crt

